% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mh_rwnn.R
\name{mh_rwnn}
\alias{mh_rwnn}
\alias{mh_rwnn.default}
\alias{mh_rwnn.formula}
\title{Metropolis-Hastings sampling random weight neural networks}
\usage{
mh_rwnn(X, y, formula, data, N_hidden = c(), lambda = NULL, control = list())

\method{mh_rwnn}{default}(X, y, N_hidden = c(), lambda = NULL, control = list())

\method{mh_rwnn}{formula}(formula, data, N_hidden = c(), lambda = NULL, control = list())
}
\arguments{
\item{X}{A matrix of observed features used to estimate the parameters of the output layer.}

\item{y}{A vector of observed targets used to estimate the parameters of the output layer.}

\item{formula}{A \link{formula} specifying features and targets used to estimate the parameters of the output layer.}

\item{data}{A data-set (either a \link{data.frame} or a \link[tibble]{tibble}) used to estimate the parameters of the output layer.}

\item{N_hidden}{A vector of integers designating the number of neurons in each of the hidden layers (the length of the list is taken as the number of hidden layers).}

\item{lambda}{The penalisation constant used when training the output layers of the RWNN.}

\item{control}{A list of additional arguments passed to the \link{control_mh_rwnn} function (includes arguments passed to the \link{control_rwnn} function.).}
}
\value{
The return object will depend on the choice of \code{method} passed through the \code{control} argument: 
\describe{
    \item{\code{"map"}}{An \link{RWNN-object}.}
    \item{\code{"resample"}}{An \link{ERWNN-object}.}
    \item{\code{"posterior"}}{An \link{SRWNN-object}.}
}
}
\description{
Uses Metropolis-Hastings sampling to pre-train sampling distribution of the hidden layers in random weight neural network models.
}
\examples{
N <- 2000
p <- 5

s <- seq(0, pi, length.out = N)
X <- matrix(NA, ncol = p, nrow = N)
X[, 1] <- sin(s)
X[, 2] <- cos(s)
X[, 3] <- s
X[, 4] <- s^2
X[, 5] <- s^3

beta <- matrix(rnorm(p), ncol = 1) 
y <- X \%*\% beta + rnorm(N, 0, 1)

N_hidden <- 10
lambda <- 1

## Returning an RWNN object using just the MAP estimate of the weights
\dontrun{
mh_rwnn(X = X, y = y, N_hidden = N_hidden, 
        lambda = lambda, control = list(method = "map"))
}

## Returning an ERWNN object resampling weights from the created posterior sample
\dontrun{
mh_rwnn(X = X, y = y, N_hidden = N_hidden, 
        lambda = lambda, control = list(method = "stack"))
}

## Returning an SRWNN object of the sampled posterior
\dontrun{
mh_rwnn(X = X, y = y, N_hidden = N_hidden, 
        lambda = lambda, control = list(method = "posterior"))
}
N <- 2000
p <- 5

s <- seq(0, pi, length.out = N)
X <- matrix(NA, ncol = p, nrow = N)
X[, 1] <- sin(s)
X[, 2] <- cos(s)
X[, 3] <- s
X[, 4] <- s^2
X[, 5] <- s^3

beta <- matrix(rnorm(p), ncol = 1) 
y <- X \%*\% beta + rnorm(N, 0, 1)

N_hidden <- 10
lambda <- 1

## Returning an RWNN object using just the MAP estimate of the weights
\dontrun{
mh_rwnn(X = X, y = y, N_hidden = N_hidden, 
        lambda = lambda, control = list(method = "map"))
}

## Returning an ERWNN object resampling weights from the created posterior sample
\dontrun{
mh_rwnn(X = X, y = y, N_hidden = N_hidden, 
        lambda = lambda, control = list(method = "stack"))
}

## Returning an SRWNN object of the sampled posterior
\dontrun{
mh_rwnn(X = X, y = y, N_hidden = N_hidden, 
        lambda = lambda, control = list(method = "posterior"))
}
}
